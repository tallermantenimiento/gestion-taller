<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Preparaci√≥n de pedidos</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  /* === ESTILOS BASE === */
  body { margin:0; font-family:Segoe UI,Arial; background:#0b1220; color:#e6edf7; padding:24px; }
  .top { display:flex; align-items:center; justify-content:space-between; margin-bottom:16px; }

  /* === BOTONES CORPORATIVOS === */
  .btn {
    background:linear-gradient(180deg,#0f3c55,#0b2a3d);
    border:1px solid rgba(255,255,255,.15);
    color:#6dd6ff;
    padding:8px 14px;
    border-radius:10px;
    cursor:pointer;
    font-weight:600;
    transition: filter 0.2s;
  }
  .btn:hover { filter:brightness(1.15); }

  .btn-danger { background:linear-gradient(180deg,#7f1d1d,#450a0a); border-color:#b91c1c; color:#fecaca; }
  .btn-success { background:linear-gradient(180deg,#14532d,#052e16); border-color:#16a34a; color:#86efac; }

  /* === BOT√ìN MINI === */
  .btn-mini {
    background: linear-gradient(180deg, #0f3c55, #0b2a3d);
    border: 1px solid rgba(255,255,255,.15);
    color: #6dd6ff;
    padding: 5px 12px;
    font-size: 11px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    transition: filter 0.2s, box-shadow 0.2s;
    white-space: nowrap;
    margin-right: 6px;
  }
  .btn-mini:hover { filter: brightness(1.2); box-shadow: 0 0 8px rgba(109, 214, 255, 0.2); }
  .btn-mini.disabled { background: transparent; border: 1px solid rgba(74, 222, 128, 0.2); color: #4ade80; cursor: default; box-shadow: none; filter: none; }
  .btn-mini.unassigned { background: linear-gradient(180deg, #7f1d1d, #450a0a); border-color: rgba(239,68,68,.55); color: #fecaca; }


  /* LAYOUT */
  .card { background:linear-gradient(180deg,#0f172a,#020617); border-radius:16px; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.5); }
  .hidden { display:none !important; }
  .section-title { margin:18px 0 6px 0; font-size:13px; color:#9fb0c8; letter-spacing:.08em; font-weight: 700; text-transform: uppercase; }

  /* TABLAS E INPUTS */
  table { width:100%; border-collapse:collapse; margin-top:6px; }
  th, td { border-bottom:1px solid rgba(255,255,255,.08); padding:8px; vertical-align: middle; }
  th { color:#9fb0c8; font-size:12px; text-align:left; }
  input { background:#020617; border:1px solid rgba(255,255,255,.12); color:#e6edf7; border-radius:8px; padding:6px; }
  input[type=number] { width:70px; text-align: center; }
  input:focus { outline: none; border-color: #6dd6ff; }

  /* Input especial Unidades */
  .input-unidades { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; font-size: 14px; font-weight: bold; width: 60px; text-align: center; border-radius: 6px; padding: 4px; transition: all 0.3s; }
  .input-unidades:focus { border-color: #6dd6ff; background: rgba(0,0,0,0.3); }

  /* Estado Filas */
  tr.ok { background: linear-gradient(180deg, rgba(24,130,72,.28), rgba(12,78,44,.18)); box-shadow: inset 0 0 0 1px rgba(110,255,170,.18); }
  tr.ok td { color: #e9fff1; }
  .flash-limit { animation: clampFlash .5s ease-in-out 1; border-color: #ef4444 !important; }
  @keyframes clampFlash { 0%, 100% { box-shadow: 0 0 0 0 rgba(239,68,68,0); } 50% { box-shadow: 0 0 0 4px rgba(239,68,68,0.25); } }

  /* Listado */
  .list { display:grid; grid-template-columns:repeat(auto-fill,minmax(280px,1fr)); gap:12px; }
  .item { padding:12px; border-radius:12px; background:#020617; border:1px solid rgba(255,255,255,.08); cursor:pointer; transition: border-color 0.2s; }
  .item:hover { border-color:rgba(109,214,255,.35); background: rgba(255,255,255,0.02); }
  .badge { font-size:11px; padding:2px 8px; border-radius:999px; font-weight: bold; text-transform: uppercase; display:inline-flex; align-items:center; gap:6px; }
  .b-p { background:#f59e0b; color:#111; }
  .b-pa { background:#fb923c; color:#111; }
  .b-c { background:#22c55e; color:#111; }
  .b-fab { background:#16a34a; color:#06100a; border:1px solid rgba(255,255,255,.25); }
  .b-na { background:#ef4444; color:#111; }

  .dot { width:8px; height:8px; border-radius:50%; background:currentColor; display:inline-block; }

  /* Control Panel */
  .control-panel { display:flex; gap:12px; align-items:center; flex-wrap:wrap; padding:12px; margin: 15px 0; background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08); border-radius: 12px; }
  .radio-group { display:flex; gap:10px; }
  .radio-btn { display:flex; align-items:center; gap:6px; padding:6px 12px; border-radius: 999px; border: 1px solid rgba(255,255,255,.15); background: rgba(0,0,0,.3); cursor:pointer; user-select: none; }
  .radio-btn input { margin:0; }
  .actions { display:flex; gap:10px; align-items:center; justify-content:space-between; margin-top:20px; padding-top:15px; border-top:1px solid rgba(255,255,255,0.1); }

  /* ======= VINCULACI√ìN ======= */
  .link-pill { display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; font-size:11px; font-weight:800; border:1px solid rgba(255,255,255,.15); background: rgba(0,0,0,.25); color:#9fb0c8; margin-right:6px; }
  .link-pill.ok { color:#86efac; border-color: rgba(34,197,94,.35); background: rgba(34,197,94,.12); }
  .link-pill.warn { color:#fbbf24; border-color: rgba(245,158,11,.35); background: rgba(245,158,11,.12); }
  .link-pill.danger { color:#fca5a5; border-color: rgba(239,68,68,.35); background: rgba(239,68,68,.12); }

  .stock-mini { font-size:11px; opacity:.75; margin-top:4px; display:flex; gap:10px; flex-wrap:wrap; }
  .stock-mini b { opacity:1; }

  /* === MODALES === */
  .modal-backdrop { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); backdrop-filter:blur(4px); z-index:1000; display:flex; align-items:center; justify-content:center; opacity:0; pointer-events:none; transition:opacity 0.2s; }
  .modal-backdrop.active { opacity:1; pointer-events:auto; }

  .modal-box { width:92%; max-width:760px; background:#0f172a; border:1px solid rgba(255,255,255,0.1); border-radius:16px; padding:20px; box-shadow:0 20px 50px rgba(0,0,0,0.5); transform:translateY(20px); transition:transform 0.2s; }
  .modal-backdrop.active .modal-box { transform:translateY(0); }

  .modal-title { font-size:16px; font-weight:bold; color:#fff; margin-bottom:12px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px; display:flex; justify-content:space-between; gap:12px; align-items:center; }
  .modal-field { margin-bottom:14px; }
  .modal-label { display:block; font-size:12px; color:#9fb0c8; margin-bottom:5px; font-weight:600; }

  .input-group { display:flex; gap:8px; }
  .modal-select { flex:1; background:#020617; border:1px solid rgba(255,255,255,0.15); color:#fff; padding:8px; border-radius:8px; outline:none; font-family:inherit; }
  .modal-input { flex:1; background:#020617; border:1px solid #38bdf8; color:#fff; padding:8px; border-radius:8px; outline:none; }
  .btn-icon { width:36px; padding:0; display:flex; align-items:center; justify-content:center; font-size:18px; }

  .modal-info { background:rgba(56,189,248,0.1); border:1px solid rgba(56,189,248,0.2); color:#38bdf8; padding:10px; border-radius:8px; font-size:12px; margin-bottom:16px; }

  /* Modal Vincular */
  .link-grid { display:grid; grid-template-columns: 260px 1fr; gap:14px; }
  @media(max-width: 820px){ .link-grid{ grid-template-columns:1fr; } }
  .link-panel { background: rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.10); border-radius:12px; padding:12px; }
  .link-search { display:flex; gap:8px; align-items:center; background: rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.10); border-radius:10px; padding:8px 10px; margin-bottom:10px; }
  .link-search input { width:100%; background:transparent; border:none; color:#e6edf7; outline:none; padding:0; }
  .link-list { max-height: 420px; overflow:auto; border-radius:10px; border:1px solid rgba(255,255,255,.08); background: rgba(0,0,0,.15); }
  .link-item { padding:10px; border-bottom:1px solid rgba(255,255,255,.06); cursor:pointer; }
  .link-item:hover { background: rgba(255,255,255,.04); }
  .link-item .t { font-weight:800; color:#fff; }
  .link-item .s { font-size:11px; color:#9fb0c8; margin-top:2px; display:flex; justify-content:space-between; gap:10px; }
  .link-item.active { outline:2px solid rgba(56,189,248,.35); background: rgba(56,189,248,.08); }
  .small { font-size:11px; opacity:.75; }

/* === FOCUS / AUTO-OPEN (devolver no asignado) === */
.focus-banner{
  margin:12px 0 0;
  padding:10px 12px;
  border-radius:14px;
  background:rgba(255,90,90,0.16);
  border:1px solid rgba(255,90,90,0.55);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}
.focus-banner .ref{
  font-weight:900;
  color:#ffd0d0;
}
.focus-target{
  outline:3px solid rgba(255,90,90,0.85);
  box-shadow:0 0 0 4px rgba(255,90,90,0.25), 0 0 18px rgba(255,90,90,0.35);
  animation:focusPulse 1.1s ease-in-out infinite alternate;
}
@keyframes focusPulse{
  from{ filter:brightness(1.0); transform:translateZ(0); }
  to{ filter:brightness(1.18); }
}

</style>

<script type="module" src="cloud_sync.js"></script>
</head>
<body>

<div class="top">
  <div style="display:flex;gap:10px">
    <button class="btn" onclick="volverIndex()">‚Üê Volver al index</button>
    <button class="btn" onclick="volverLista()">‚Üê Volver a pedidos</button>
  </div>
  <h2 style="margin:0">Preparaci√≥n</h2>

<div id="focusBanner" class="focus-banner" style="display:none">
  <div>‚ö†Ô∏è Pedido con <b>material no asignado</b>: <span class="ref"></span></div>
  <button class="btn" id="btnAbrirFocus">Abrir ficha</button>
</div>

</div>

<div id="vistaLista" class="card">
  <h3 style="margin:0 0 10px 0;">Pedidos en curso</h3>
  <div id="lista" class="list"></div>
</div>

<div id="vistaDetalle" class="card hidden">
  <div style="display:flex; justify-content:space-between; align-items:flex-end; gap:14px;">
      <div>
        <div style="font-size:12px; color:#9fb0c8;">REFERENCIA</div>
        <div style="font-size:18px; font-weight:bold; color:#fff;" id="ref"></div>
        <div style="display:flex; gap:10px; align-items:center; margin-top:8px; flex-wrap:wrap;">
            <div style="font-size:14px; color:#6dd6ff;" id="concepto"></div>
            <div style="font-size:13px; color:#9fb0c8;" id="empresaPrep"></div>
            <span id="pillFab" class="badge b-fab hidden"><span class="dot"></span> En fabricaci√≥n</span>
            <span id="pillNoAsig" class="badge b-na hidden" style="cursor:pointer" onclick="abrirModalNoAsignado()"><span class="dot"></span> No asignado</span>
            <div style="display:flex; align-items:center; gap:5px; background:rgba(0,0,0,0.3); padding:4px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.1);">
                <span style="font-size:11px; color:#9fb0c8; text-transform:uppercase; font-weight:bold;">Uds:</span>
                <input type="number" id="inputUnidades" class="input-unidades" min="0" onchange="guardarUnidadesManual()">
            </div>
        </div>
      </div>
      <button class="btn btn-success" onclick="marcarTodoOk()">‚úì OK Todo</button>
  </div>

  <div id="panelHierro" class="hidden control-panel">
      <span style="font-weight:700; color:#cbd5e1;">Tipo de Perfiler√≠a:</span>
      <div class="radio-group">
          <label class="radio-btn"><input type="radio" name="th" value="galvanizado" onchange="guardarTipoHierro()"> Galvanizado</label>
          <label class="radio-btn"><input type="radio" name="th" value="negro" onchange="guardarTipoHierro()"> Negro</label>
      </div>
      <span style="font-size:11px; opacity:0.6; margin-left:auto;">(Requerido para guardar barras)</span>
  </div>

  <div id="bloqueBarras" class="hidden">
    <div class="section-title">PERFILER√çA ¬∑ BARRAS</div>
    <table>
      <thead><tr>
        <th width="30">OK</th>
        <th>Material</th>
        <th>Pedida</th>
        <th>Recibida</th>
        <th width="220">Acci√≥n</th>
        <th>Obs</th>
      </tr></thead>
      <tbody id="tbodyBarras"></tbody>
    </table>
  </div>

  <div id="bloqueUnidades" class="hidden">
    <div class="section-title">ACCESORIOS ¬∑ UNIDADES</div>
    <table>
      <thead><tr>
        <th width="30">OK</th>
        <th>Material</th>
        <th>Pedida</th>
        <th>Recibida</th>
        <th width="220">Acci√≥n</th>
        <th>Obs</th>
      </tr></thead>
      <tbody id="tbodyUnidades"></tbody>
    </table>
  </div>

  <div class="actions">
    <button class="btn-danger btn" onclick="eliminarPedido()">üóë Eliminar pedido</button>
    <button class="btn" onclick="confirmarTodoRecepcion()">üíæ Mandar a fabricaci√≥n</button>
  </div>
</div>

<!-- MODAL CREACI√ìN MATERIAL (si no existe en Stock) -->
<div id="modalCrear" class="modal-backdrop">
  <div class="modal-box" style="max-width:540px;">
      <div class="modal-title">
        <span>Crear Ficha de Stock</span>
        <button class="btn" style="background:transparent;border:none;color:#9fb0c8;" onclick="cerrarModalCreacion()">‚úï</button>
      </div>

      <div class="modal-info">
          El material <strong><span id="modMatName"></span></strong> no existe.<br>
          Def√≠nelo para a√±adirlo al stock.
      </div>

      <div class="modal-field">
          <span class="modal-label">CATEGOR√çA</span>
          <div class="input-group">
              <select id="modCatSelect" class="modal-select" onchange="cargarGruposModal()"></select>
              <input id="modCatInput" class="modal-input hidden" placeholder="Nueva Categor√≠a...">
              <button class="btn btn-icon" onclick="toggleInput('cat')">Ôºã</button>
          </div>
      </div>

      <div class="modal-field">
          <span class="modal-label">GRUPO / FAMILIA</span>
          <div class="input-group">
              <select id="modGrpSelect" class="modal-select"></select>
              <input id="modGrpInput" class="modal-input hidden" placeholder="Nuevo Grupo...">
              <button class="btn btn-icon" onclick="toggleInput('grp')">Ôºã</button>
          </div>
      </div>

      <div style="display:flex; gap:12px;">
          <div class="modal-field" style="flex:1;">
              <span class="modal-label">CANTIDAD A SUMAR</span>
              <input id="modQtyInput" type="number" class="modal-select" style="width:100%; box-sizing:border-box; border-color:#38bdf8; color:#38bdf8; font-weight:bold; text-align:center;">
          </div>

          <div class="modal-field" style="flex:1;">
              <span class="modal-label">UNIDAD (Ej: Caja)</span>
              <input id="modUnitInput" class="modal-select" placeholder="ud" style="width:100%; box-sizing:border-box;">
          </div>

          <div class="modal-field" style="width:80px;">
              <span class="modal-label">M√çNIMO</span>
              <input id="modMinInput" type="number" class="modal-select" placeholder="0" style="width:100%; box-sizing:border-box; text-align:center;">
          </div>
      </div>

      <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
          <button class="btn" style="background:transparent; border:none; color:#9fb0c8;" onclick="cerrarModalCreacion()">Cancelar</button>
          <button class="btn btn-success" onclick="guardarNuevoMaterial()">Guardar y A√±adir</button>
      </div>
  </div>
</div>

<!-- MODAL VINCULAR -->
<div id="modalVincular" class="modal-backdrop">
  <div class="modal-box">
    <div class="modal-title">
      <span>Vincular material de Stock</span>
      <button class="btn" style="background:transparent;border:none;color:#9fb0c8;" onclick="cerrarModalVincular()">‚úï</button>
    </div>

    <div class="modal-info" style="margin-bottom:12px;">
      L√≠nea de pedido: <strong id="linkLineName"></strong>
      <div class="small" style="margin-top:6px;">
        Consejo: vincula una vez y el sistema lo recordar√° para pr√≥ximos pedidos con el mismo nombre.
      </div>
    </div>

    <div class="link-grid">
      <div class="link-panel">
        <div class="modal-label" style="margin-bottom:6px;">Buscar</div>
        <div class="link-search">
          <span style="opacity:.75">üîé</span>
          <input id="linkSearch" placeholder="Escribe para filtrar..." autocomplete="off" />
        </div>
        <div class="small">Se muestran materiales del Stock (con categor√≠a y grupo).</div>
      </div>

      <div class="link-panel">
        <div class="modal-label" style="margin-bottom:6px;">Resultados</div>
        <div id="linkResults" class="link-list"></div>
      </div>
    </div>

    <div style="display:flex; justify-content:space-between; gap:10px; margin-top:14px; align-items:center; flex-wrap:wrap;">
      <button class="btn btn-danger" onclick="desvincularActual()">Desvincular</button>
      <div style="display:flex; gap:10px; margin-left:auto;">
        <button class="btn" onclick="cerrarModalVincular()">Cancelar</button>
        <button class="btn btn-success" onclick="confirmarVinculo()">Vincular</button>
      </div>
    </div>
  </div>
</div>


<!-- MODAL NO ASIGNADO (material prestado pendiente de devolver) -->
<div id="modalNoAsignado" class="modal-backdrop">
  <div class="modal-box" style="max-width:760px;">
    <div class="modal-title">
      <span>Material NO asignado ¬∑ Pendiente de devolver</span>
      <button class="btn" style="background:transparent;border:none;color:#9fb0c8;" onclick="cerrarModalNoAsignado()">‚úï</button>
    </div>

    <div class="modal-info" style="margin-bottom:12px;">
      Este pedido ha consumido material <strong>no asignado</strong>. Devu√©lvelo cuando llegue su stock asignado.
    </div>

    <div id="noAsigBody" style="max-height:420px; overflow:auto; border:1px solid rgba(255,255,255,.08); border-radius:12px; background: rgba(0,0,0,.15);">
      <!-- contenido din√°mico -->
    </div>

    <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:14px; align-items:center; flex-wrap:wrap;">
      <button class="btn" onclick="cerrarModalNoAsignado()">Cerrar</button>
    </div>
  </div>
</div>


<!-- Firebase (Compat, sin bundlers) -->
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore-compat.js"></script>

<script>
/* =======================================================================================
   PREPARACI√ìN DE PEDIDOS (vNEXT)
   - Pill Pendiente/Parcial/Completo: por RECEPCI√ìN (qty_recibida).
   - Auto-cierra cuando TODO est√° RECIBIDO (qty_recibida>=qty_pedida).
   - En este ajuste: auto-cierre => auto-mandar a fabricaci√≥n antes de eliminar de Preparaci√≥n.
   - ‚ÄúMarcar en fabricaci√≥n‚Äù eliminado (ya existe ‚ÄúMandar a fabricaci√≥n‚Äù).
======================================================================================= */

/* ========= CONSTANTES ========= */
const LS = localStorage;

function normRef(s){ return (s||'').toString().trim().toLowerCase(); }
const KP = r => "prep_recepcion_" + r;
const KM = r => "prep_meta_" + r;

const STOCK_DB_KEY = "taller_stock_v3_data";
const LINK_MAP_KEY = "prep_stock_linkmap_v1";
const UNASSIGNED_GLOBAL_KEY = "unassigned_borrow_global_v1";

// === Sync local entre pesta√±as/ventanas (LocalStorage) ===
// IMPORTANTE: si abres los HTML con file://, cada archivo tiene un origen distinto y NO comparte localStorage.
// Para probar sincronizaci√≥n local, abre con un servidor (http://localhost) o en GitHub Pages.
window.addEventListener('storage', (ev)=>{
  try{
    if(!ev) return;
    if(ev.key===STOCK_DB_KEY || ev.key===UNASSIGNED_GLOBAL_KEY){
      // Si hay un pedido abierto, refrescamos esa ficha; si no, refrescamos el listado.
      if(typeof refActual==='string' && refActual){
        if(typeof abrirPedido==='function') abrirPedido(refActual);
        else if(typeof cargarLista==='function') cargarLista();
      }else{
        if(typeof cargarLista==='function') cargarLista();
      }
    }
  }catch(e){}
});

const UNASSIGNED_KEY = r => "prep_unassigned_" + r; // respaldo opcional


/* ========= FIRESTORE (igual que stock.html) ========= */
const USE_FIRESTORE_STOCK = true;
const FIRESTORE_DOC_PATH = { col: "taller_stock", doc: "main" };

const firebaseConfig = {
  apiKey: "AIzaSyDGIfICSG_KE6QzmKHj3CzgvYeHaUcgARo",
  authDomain: "gestion-taller-2a439.firebaseapp.com",
  projectId: "gestion-taller-2a439",
  storageBucket: "gestion-taller-2a439.firebasestorage.app",
  messagingSenderId: "498579673950",
  appId: "1:498579673950:web:eb626781a5b509957db5cf"
};

let fbApp=null, fbAuth=null, fbDb=null;
let fsUnsub=null;
let fsReady=false;
let ignoreNextLocalSave=false;
let pendingSaveTimer=null;

/* ========= STATE ========= */
let refActual = "";
let estadoMateriales = [];
let metaActual = {};
let pendingCreation = null;

let stockMaterials = [];
let stockMovements = [];
let stockCategoryOrder = [];

let linkMap = {}; // { "keyNorm|unit": { matId, name, cat, grp, unit } }
let linkModalCtx = null; // { lineIndex, chosenMatId }

/* ========= HELPERS ========= */
const uuid = () => Math.random().toString(36).substr(2,9);

function normName(s){
  return String(s||"")
    .trim()
    .toLowerCase()
    .replace(/\s+/g," ")
    .replace(/[‚Äô'"]/g,"")
    .replace(/√ó/g,"x");
}
function linkKeyFor(line){
  const n = normName(line.mat);
  const u = normName(line.unit || "");
  return `${n}|${u}`;
}
function toNum(x){ const n = Number(x); return isNaN(n)?0:n; }


// Busca la referencia del pedido a partir de un PID (id interno) dentro de la base LDHDB / PREP.
// Soporta diferentes nombres hist√≥ricos de campos: pedido_uid, pedidoUid, pid, pedido_id, etc.
function findRefByPid(pid){
  try{
    if(!pid) return null;
    pid = String(pid).trim();

    // 1) Lectura directa de LDH_DB (todas las bolsas posibles)
    let db = {};
    try{
      const raw = LS.getItem("ldh_db");
      if(raw) db = JSON.parse(raw);
    }catch(e){ db = {}; }

    const pools = []
      .concat((db.deliveries||[]),(db.trabajos||[]))
      .concat((db.fabricacion||[]),(db.pintura||[]),(db.almacen||[]),(db.archivo||[]))
      .concat((db.fab||[]),(db.paint||[]),(db.store||[])); // por si existiera otra convenci√≥n

    for(const t of pools){
      const meta = (t && (t.meta || t)) || null; // a veces anidado, a veces plano
      if(!meta) continue;

      const cands = [
        meta.id, meta._id, meta.uid,
        meta.pedido_uid, meta.pedidoUid, meta.pid,
        meta.pedido_id, meta.pedidoId, meta.id_pedido
      ].filter(Boolean).map(v => String(v).trim());

      if(cands.includes(pid)){
        const ref = String(meta.referencia || meta.ref || meta.nombre || meta.titulo || meta.referenciaTrabajo || "").trim();
        return ref || null;
      }
    }

    // 2) Mirar en metas locales de Preparaci√≥n (prep_meta_*)
    for(let i=0;i<LS.length;i++){
      const key = LS.key(i);
      if(!key || !key.startsWith("prep_meta_")) continue;
      try{
        const meta = JSON.parse(LS.getItem(key));
        if(!meta) continue;
        const cands = [
          meta.pedido_uid, meta.pedidoUid, meta.pid,
          meta.pedido_id, meta.pedidoId, meta.id_pedido
        ].filter(Boolean).map(v => String(v).trim());
        if(cands.includes(pid)){
          const ref = String(meta.referencia || meta.ref || "").trim();
          // Si la meta no trae referencia, la inferimos de la clave prep_meta_<REF>
          const inferred = String(key).replace(/^prep_meta_/, "");
          return (ref || inferred || null);
        }
      }catch(e){}
    }

    // 3) Intento final: si el PID parece una referencia textual simple, devolverlo
    if(pid.length < 80 && !pid.includes("/") && !pid.includes("http")){
      if(LS.getItem("prep_meta_" + pid)) return pid;
    }

    return null;
  }catch(e){
    console.warn("findRefByPid() error:", e);
    return null;
  }
}
/* ========= NO ASIGNADO (devoluci√≥n desde Preparaci√≥n) ========= */
function _uaItems(){
  const ua = metaActual && metaActual.unassignedBorrow;
  if(!ua || !Array.isArray(ua.items)) return [];
  return ua.items;
}
function _uaMatchKey(line){
  const linked = getLinkedMatIdForLine(line) || line.linked_matId || '';
  if(linked) return 'id:'+linked;
  return 'n:'+normName(line.mat||'')+'|'+normName(line.unit||'');
}
function _uaFindForLine(line){
  const items=_uaItems();
  if(items.length===0) return null;
  const key=_uaMatchKey(line);
  for(let i=0;i<items.length;i++){
    const it=items[i]||{};
    const pending=toNum(it.qtyPending ?? it.pending ?? it.qty_pending);
    if(pending<=0) continue;
    const itKey = it.key || (it.matId ? ('id:'+it.matId) : ('n:'+normName(it.name||it.mat||'')+'|'+normName(it.unit||'')));
    if(String(itKey)===String(key)) return { idx:i, item:it, pending:pending };
  }
  // fallback por nombre
  const nkey='n:'+normName(line.mat||'')+'|'+normName(line.unit||'');
  for(let i=0;i<items.length;i++){
    const it=items[i]||{};
    const pending=toNum(it.qtyPending ?? it.pending ?? it.qty_pending);
    if(pending<=0) continue;
    const itKey = it.key || (it.matId ? ('id:'+it.matId) : ('n:'+normName(it.name||it.mat||'')+'|'+normName(it.unit||'')));
    if(String(itKey)===String(nkey)) return { idx:i, item:it, pending:pending };
  }
  return null;
}
function devolverNoAsignadoLinea(lineIndex){
  const line = estadoMateriales[lineIndex];
  const rec = _uaFindForLine(line);
  if(!rec){ alert('No hay deuda no asignada para esta l√≠nea.'); return; }

  // cantidad a devolver = pendiente completo (de momento)
  const qty = rec.pending;
  if(qty<=0) return;

  // localizar material real para sumar a stock
  const check = _addToRealStock_byLinkedOrName(line, (String(line.unit||'').toLowerCase()==='barra'? metaActual.tipo_hierro : null));
  if(!check.success){
    alert('No se pudo identificar el material en Stock para devolver. Vincula primero el material.');
    return;
  }
  stockMovements.push({ id: uuid(), matId: check.matId, type:'in', qty: qty, date: new Date().toISOString(), ref: refActual, concept: metaActual.concepto||'', reason:'devolucion_no_asignado' });
  saveStockLocal();

  // limpiar deuda en meta
  const items = _uaItems();
  items[rec.idx].qtyPending = 0;
  // eliminar items a 0
  metaActual.unassignedBorrow.items = items.filter(it=>toNum(it.qtyPending ?? it.pending ?? it.qty_pending)>0);

  if(metaActual.unassignedBorrow.items.length===0){
    delete metaActual.unassignedBorrow;
  }
  LS.setItem(KM(refActual), JSON.stringify(metaActual));

  alert(`‚úÖ Devuelto material no asignado.
Material: ${check.mat.name}
Cantidad: ${qty}
Stock actual: ${getStockQty(check.matId)}`);
  renderTabla();
  cargarLista();
}

/* ========= NO ASIGNADO (material prestado) =========
   - Persistente por pedido: metaActual.unassignedBorrow
   - Se replica en ldh_db (si existe entrega) para que otros m√≥dulos puedan leerlo en el futuro.
*/
function ensureUnassigned(meta){
  if(!meta) meta = {};
  if(!meta.unassignedBorrow || typeof meta.unassignedBorrow !== 'object'){
    meta.unassignedBorrow = { items: [], updatedAt: 0 };
  }
  if(!Array.isArray(meta.unassignedBorrow.items)) meta.unassignedBorrow.items = [];
  return meta.unassignedBorrow;
}
function unassignedTotals(ub){
  ub = ub || { items: [] };
  const items = Array.isArray(ub.items) ? ub.items : [];
  const lines = items.filter(it => toNum(it.qtyPending) > 0);
  const totalQty = lines.reduce((a,it)=>a + toNum(it.qtyPending), 0);
  return { lines: lines.length, totalQty };
}

function _loadUnassignedGlobalMap(){
  try { return JSON.parse(LS.getItem(UNASSIGNED_GLOBAL_KEY) || "{}") || {}; }
  catch(e){ return {}; }
}
function _saveUnassignedGlobalMap(map){
  LS.setItem(UNASSIGNED_GLOBAL_KEY, JSON.stringify(map || {}));
}
function getGlobalBorrow(ref){
  const map = _loadUnassignedGlobalMap();
  return map[ref] || null;
}
function setGlobalBorrow(ref, ub){
  const map = _loadUnassignedGlobalMap();
  map[ref] = ub || { items: [], updatedAt: Date.now() };
  _saveUnassignedGlobalMap(map);
}
function clearGlobalBorrow(ref){
  const map = _loadUnassignedGlobalMap();
  if(ref in map){
    delete map[ref];
    _saveUnassignedGlobalMap(map);
  }
}
function saveMetaActual(){
  if(!refActual) return;
  metaActual.unassignedBorrow = ensureUnassigned(metaActual);
  metaActual.unassignedBorrow.updatedAt = Date.now();

  // Persistencia global (independiente del m√≥dulo) para que no desaparezca aunque el pedido cambie de fase
  const t = unassignedTotals(metaActual.unassignedBorrow);
  if(t.lines > 0){
    setGlobalBorrow(refActual, metaActual.unassignedBorrow);
  } else {
    clearGlobalBorrow(refActual);
  }

  LS.setItem(KM(refActual), JSON.stringify(metaActual));
  mirrorUnassignedToLdhDb();
}
function mirrorUnassignedToLdhDb(){
  try{
    const rawDb = LS.getItem("ldh_db");
    if(!rawDb) return;
    const db = JSON.parse(rawDb) || {};
    if(!Array.isArray(db.deliveries)) return;
    const idx = db.deliveries.findIndex(d => d && d.ref === refActual);
    if(idx < 0) return;
    db.deliveries[idx].unassignedBorrow = (metaActual.unassignedBorrow || getGlobalBorrow(refActual) || { items: [], updatedAt: Date.now() });
    LS.setItem("ldh_db", JSON.stringify(db));
  }catch(e){ /* silent */ }
}

function ldhHasDelivery(ref){
  try{
    const rawDb = LS.getItem("ldh_db");
    if(!rawDb) return false;
    const db = JSON.parse(rawDb) || {};
    if(!Array.isArray(db.deliveries)) return false;
    return db.deliveries.some(d => d && d.ref === ref);
  }catch(e){ return false; }
}

function updateNoAsigPill(){
  const ub = ensureUnassigned(metaActual);
  const t = unassignedTotals(ub);
  const pill = document.getElementById("pillNoAsig");
  if(!pill) return;
  if(t.lines > 0){
    pill.classList.remove("hidden");
    pill.innerHTML = `<span class="dot"></span> No asignado: <b>${t.lines}</b> ¬∑ <b>${t.totalQty}</b>`;
  }else{
    pill.classList.add("hidden");
  }
}
function abrirModalNoAsignado(){
  if(!refActual) return;
  renderModalNoAsignado();
  document.getElementById("modalNoAsignado").classList.add("active");
}
function cerrarModalNoAsignado(){
  document.getElementById("modalNoAsignado").classList.remove("active");
}
function renderModalNoAsignado(){
  const host = document.getElementById("noAsigBody");
  const ub = ensureUnassigned(metaActual);
  const lines = (ub.items || []).filter(it => toNum(it.qtyPending) > 0);

  if(lines.length === 0){
    host.innerHTML = `<div style="padding:14px; opacity:.75;">No hay material pendiente de devolver.</div>`;
    return;
  }

  const rows = lines.map((it, i) => {
    const qty = toNum(it.qtyPending);
    const unit = it.unit ? ` <span style="opacity:.7">${it.unit}</span>` : "";
    const matName = (it.name || it.matName || it.matId || "Material");
    return `
      <div style="display:flex; gap:10px; align-items:center; padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.06);">
        <div style="flex:1; min-width:0;">
          <div style="font-weight:800; color:#fff; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${matName}</div>
          <div style="font-size:12px; color:#9fb0c8; margin-top:2px;">
            Pendiente: <b style="color:#fecaca">${qty}</b>${unit}
          </div>
        </div>
        <button class="btn btn-success" onclick="devolverNoAsignado('${it.matId}', ${qty})">Devolver</button>
      </div>
    `;
  }).join("");

  host.innerHTML = rows;
}
function devolverNoAsignado(matId, maxQty){
  if(!refActual) return;
  const ub = ensureUnassigned(metaActual);
  const it = (ub.items || []).find(x => x && x.matId === matId);
  if(!it) return;

  const qtyPend = toNum(it.qtyPending);
  const max = Math.max(0, qtyPend);
  if(max <= 0) return;

  const ask = prompt(`Cantidad a DEVOLVER (m√°x. ${max})`, String(max));
  if(ask === null) return;
  let q = parseFloat(String(ask).replace(",", "."));
  if(isNaN(q) || q <= 0) return;
  if(q > max) q = max;

  // movimiento IN (devoluci√≥n)
  stockMovements.push({
    id: uuid(),
    matId: matId,
    type: 'in',
    qty: q,
    date: new Date().toISOString(),
    ref: refActual,
    concept: metaActual.concepto || "",
    reason: "unassigned_return"
  });
  saveStockLocal();

  it.qtyPending = Math.max(0, qtyPend - q);
  it.lastActionAt = Date.now();
  // limpia l√≠neas a 0
  ub.items = (ub.items || []).filter(x => toNum(x.qtyPending) > 0);
  metaActual.unassignedBorrow = ub;
  saveMetaActual();

  alert(`‚úÖ Devuelto material NO asignado.\nCantidad: ${q}\nStock actual: ${getStockQty(matId)}`);
  updateNoAsigPill();
  renderModalNoAsignado();
  renderTabla();
  cargarLista();
}



/* ========= FIRESTORE helpers ========= */
function fbEnsure(){
  if(fbApp) return;
  fbApp = firebase.initializeApp(firebaseConfig);
  fbAuth = firebase.auth();
  fbDb   = firebase.firestore();
}
async function fsLoginHidden(){
  try{
    if(!fbAuth.currentUser){
      await fbAuth.signInAnonymously();
    }
  }catch(e){
    console.warn("Auth an√≥nimo no disponible:", e);
  }
}
function fsDocRef(){
  return fbDb.collection(FIRESTORE_DOC_PATH.col).doc(FIRESTORE_DOC_PATH.doc);
}
async function fsLoadOnceToLocal(){
  const snap = await fsDocRef().get();
  if(!snap.exists) return false;
  const data = snap.data() || {};
  if(!Array.isArray(data.materials) || !Array.isArray(data.movements)) return false;

  ignoreNextLocalSave = true;
  LS.setItem(STOCK_DB_KEY, JSON.stringify({
    materials: data.materials || [],
    movements: data.movements || [],
    categoryOrder: data.categoryOrder || []
  }));
  ignoreNextLocalSave = false;

  stockMaterials = data.materials || [];
  stockMovements = data.movements || [];
  stockCategoryOrder = data.categoryOrder || [];
  return true;
}
function fsStartRealtimeListener(){
  if(fsUnsub) fsUnsub();
  fsUnsub = fsDocRef().onSnapshot((snap)=>{
    if(!snap.exists) return;
    const data = snap.data() || {};
    if(!Array.isArray(data.materials) || !Array.isArray(data.movements)) return;

    ignoreNextLocalSave = true;
    LS.setItem(STOCK_DB_KEY, JSON.stringify({
      materials: data.materials || [],
      movements: data.movements || [],
      categoryOrder: data.categoryOrder || []
    }));
    ignoreNextLocalSave = false;

    stockMaterials = data.materials || [];
    stockMovements = data.movements || [];
    stockCategoryOrder = data.categoryOrder || [];

    if(refActual) renderTabla();
  }, (err)=>console.warn("Firestore onSnapshot error:", err));
}
function scheduleFsSaveStock(){
  if(!USE_FIRESTORE_STOCK || !fsReady) return;
  if(ignoreNextLocalSave) return;

  clearTimeout(pendingSaveTimer);
  pendingSaveTimer = setTimeout(async ()=>{
    try{
      const payload = {
        materials: stockMaterials,
        movements: stockMovements,
        categoryOrder: stockCategoryOrder,
        updatedAt: new Date().toISOString()
      };
      await fsDocRef().set(payload, { merge: true });
    }catch(e){
      console.warn("No se pudo guardar en Firestore:", e);
    }
  }, 450);
}

/* ========= STOCK local ========= */
function loadStockLocal(){
  const raw = LS.getItem(STOCK_DB_KEY);
  const db = raw ? JSON.parse(raw) : { materials:[], movements:[], categoryOrder:[] };
  stockMaterials = Array.isArray(db.materials) ? db.materials : [];
  stockMovements = Array.isArray(db.movements) ? db.movements : [];
  stockCategoryOrder = Array.isArray(db.categoryOrder) ? db.categoryOrder : [];
}
function saveStockLocal(){
  LS.setItem(STOCK_DB_KEY, JSON.stringify({
    materials: stockMaterials,
    movements: stockMovements,
    categoryOrder: stockCategoryOrder
  }));
  scheduleFsSaveStock();
}
function getStockQty(matId){
  return stockMovements
    .filter(m => m.matId === matId)
    .reduce((acc, m) => m.type === 'in' ? acc + toNum(m.qty) : acc - toNum(m.qty), 0);
}
function getMatById(id){
  return stockMaterials.find(m => m.id === id) || null;
}

/* ========= LINKMAP ========= */
function loadLinkMap(){
  try { linkMap = JSON.parse(LS.getItem(LINK_MAP_KEY) || "{}") || {}; }
  catch(e){ linkMap = {}; }
}
function saveLinkMap(){
  LS.setItem(LINK_MAP_KEY, JSON.stringify(linkMap || {}));
}

/* ========= IMPORTACI√ìN DE DATOS DESDE CALCULO/OTROS ========= */
(function verificarImports() {
  const encontrarNumero = (obj) => {
    if (!obj) return null;
    const posiblesKeys = ["cantidad", "unidades", "units", "qty", "quantity", "amount", "totalUnits", "total"];
    for (let key of posiblesKeys) {
      if (obj[key] !== undefined && obj[key] !== null && obj[key] !== "") return parseFloat(obj[key]);
    }
    if (obj.vars) {
      for (let key of posiblesKeys) {
        if (obj.vars[key] !== undefined && obj.vars[key] !== null && obj.vars[key] !== "") return parseFloat(obj.vars[key]);
      }
    }
    return null;
  };

  // === Entrada de pedido (compatible con file://) ===
  // 1) window.name (paso directo desde C√°lculo/Index)
  let snap = null;
  try{
    const nm = String(window.name || "").trim();
    if(nm.startsWith("LDH_PREP|")){
      snap = JSON.parse(nm.slice("LDH_PREP|".length));
      // limpiar para evitar reimportar al refrescar
      try{ window.name = ""; }catch(_){}
    }
  }catch(e){ snap = null; }

  // 2) localStorage (misma origin)
  if(!snap){
    const snapRaw = LS.getItem("latest_materials_v1") || LS.getItem("pedido_en_preparacion") || LS.getItem("prep_pedido_payload");
    if(snapRaw){
      try{ snap = JSON.parse(snapRaw); }catch(e){ snap = null; }
    }
  }

  if (snap) {
    try {
      const refBase = String(snap.referencia || snap.ref || ('SIN_REF_' + Date.now())).trim();
      // UID de pedido para distinguir env√≠os distintos aunque compartan referencia
      const incomingUid = String(snap.pedido_uid || snap.pedidoUid || snap.uid || snap.pedidoId || '').trim();
      const pedidoUid = incomingUid || ('P'+Date.now().toString(36)+Math.random().toString(36).slice(2,6));

      // Si ya existe un pedido con la misma referencia pero es OTRO concepto/u otro UID, no lo pisamos:
      // generamos una referencia √∫nica con sufijo.
      let ref = refBase;
      const existsAny = !!(LS.getItem(KP(refBase)) || LS.getItem(KM(refBase)));
      if (existsAny) {
        let metaExist = {};
        try { metaExist = JSON.parse(LS.getItem(KM(refBase)) || '{}') || {}; } catch(e) { metaExist = {}; }
        const existUid = String(metaExist.pedido_uid || metaExist.pedidoUid || metaExist.uid || '').trim();
        const existConcept = String(metaExist.concepto || '').trim();
        const incConcept = String(snap.concepto || '').trim();
        const sameOrder = (existUid && existUid === pedidoUid);
        const conflict = !sameOrder && ((existConcept && incConcept && existConcept !== incConcept) || !existUid || existUid !== pedidoUid);
        if (conflict) {
          let i = 2;
          while (LS.getItem(KP(refBase + ' #' + i)) || LS.getItem(KM(refBase + ' #' + i))) i++;
          ref = refBase + ' #' + i;
        }
      }

      let qty = encontrarNumero(snap) || 1;

      let metaParaGuardar = JSON.parse(LS.getItem(KM(ref)) || "{}");
      metaParaGuardar.referencia = ref;
      metaParaGuardar.pedido_uid = pedidoUid;
      // Pedido ID inmutable (para abrir ficha aunque cambie el nombre/ref)
      if(!metaParaGuardar.pedido_id){
        metaParaGuardar.pedido_id = 'pid_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8);
      }
      if(ref !== refBase) metaParaGuardar.original_ref = refBase;

      metaParaGuardar.concepto = snap.concepto || metaParaGuardar.concepto || "";
      // Empresa por PEDIDO (no por concepto)
      const empresaIncoming = String(snap.empresa || snap.company || "").trim();
      if(empresaIncoming){
        metaParaGuardar.empresa = empresaIncoming;
        metaParaGuardar.company = empresaIncoming;
      } else {
        // normalizar nombres hist√≥ricos si ya exist√≠an
        if(!metaParaGuardar.empresa && metaParaGuardar.company) metaParaGuardar.empresa = metaParaGuardar.company;
        if(!metaParaGuardar.company && metaParaGuardar.empresa) metaParaGuardar.company = metaParaGuardar.empresa;
      }
      metaParaGuardar.unidades = qty;
      metaParaGuardar.fecha = Date.now();
      if (!metaParaGuardar.tipo_hierro) metaParaGuardar.tipo_hierro = "";
      if (metaParaGuardar.en_fabricacion === undefined) metaParaGuardar.en_fabricacion = false;

      LS.setItem(KM(ref), JSON.stringify(metaParaGuardar));

      // ADAPTADOR DE V√çNCULOS (desde C√°lculo/Configuraci√≥n de conceptos)
      // Preparaci√≥n trabaja con `linked_matId`. Sin este adaptador, si el c√°lculo
      // env√≠a el id como `stockMatId`/`matId`, la l√≠nea llega "sin v√≠nculo".
      const materialesSrc = (snap.materiales || snap.materials || snap.lineas || snap.items || []);
      const materialesImport = (materialesSrc || []).map(l => {
        if(!l || typeof l !== 'object') return l;
        // normaliza cantidades m√≠nimas esperadas por Preparaci√≥n
        if(l.qty_pedida === undefined && l.qty !== undefined) l.qty_pedida = l.qty;
        if(l.qty_recibida === undefined) l.qty_recibida = 0;
        if(l.aplicado_qty === undefined) l.aplicado_qty = 0;

        // normaliza el v√≠nculo a stock
        if(!l.linked_matId && l.stockMatId) l.linked_matId = l.stockMatId;
        if(!l.linked_matId && l.matId)      l.linked_matId = l.matId;
        if(!l.linked_matId && l.stock_matId) l.linked_matId = l.stock_matId;
        return l;
      });

      LS.setItem(KP(ref), JSON.stringify(materialesImport));

      LS.removeItem("latest_materials_v1");
      LS.removeItem("pedido_en_preparacion");
      LS.removeItem("prep_pedido_payload");
    } catch (e) { console.error("Error importando:", e); }
  }
})();

/* ========= NAVEGACI√ìN ========= */
function volverIndex(){ location.href = "index.html"; }
function volverLista(){
  document.getElementById("vistaDetalle").classList.add("hidden");
  document.getElementById("vistaLista").classList.remove("hidden");
  refActual = "";
  cargarLista();
}

/* ========= AUTO-ABRIR DESDE INDEX (openRef=...) ========= */
function _getQueryParam(name){
  try{
    const u = new URL(location.href);
    return u.searchParams.get(name);
  }catch(e){ return null; }
}
function getFocusRef(){
  try{
    const u = new URLSearchParams(window.location.search || '');
    let ref = (u.get('ref') || u.get('openRef') || u.get('referencia') || '').trim();

    if(!ref){
      const h = (window.location.hash || '').replace(/^#/, '');
      if(h.startsWith('ref=')) ref = decodeURIComponent(h.slice(4));
      else if(h.startsWith('openRef=')) ref = decodeURIComponent(h.slice(8));
    }

    if(!ref) ref = (LS.getItem('prep_focus_ref') || LS.getItem('prep_focus_hash_ref') || '').trim();

    // limpiar para no bloquear futuros clicks
    LS.removeItem('prep_focus_ref');
    LS.removeItem('prep_focus_hash_ref');

    return ref || '';
  }catch(e){ return ''; }
}

function marcarYabrirRef(ref){
  ref = (ref || '').trim();
  if(!ref) return;

  // Banner superior (si existe)
  try{
    const b = document.getElementById('focusBanner');
    if(b){
      b.style.display = 'flex';
      const s = b.querySelector('.ref');
      if(s) s.textContent = ref;
      const btn = document.getElementById('btnAbrirFocus');
      if(btn) btn.onclick = () => abrirPedido(ref);
    }
  }catch(e){}

  const refNorm = normRef(ref);

  const tryClick = (attempt) => {
    const list = document.getElementById('listaPedidos');
    if(list){
      const items = Array.from(list.querySelectorAll('.item'));
      const el = items.find(n => (n.dataset && (n.dataset.refNorm || normRef(n.dataset.ref))) === refNorm)
              || items.find(n => normRef(n.textContent).includes(refNorm));
      if(el){
        try{ el.classList.add('focus-target'); }catch(e){}
        try{ el.scrollIntoView({behavior:'smooth', block:'center'}); }catch(e){}
        // Marcar visualmente y centrar en lista (sin auto-abrir)
        return;
      }
    }
    if(attempt < 12) setTimeout(()=>tryClick(attempt+1), 180);
  };

  tryClick(0);
}

function autoAbrirDesdeQuery(){
  const ref = getFocusRef();
  if(ref) marcarYabrirRef(ref);
}

/* ========= LISTA DE PEDIDOS (pill por RECEPCI√ìN) ========= */
function cargarLista() {
  const lista = document.getElementById("lista");
  lista.innerHTML = "";
  const keys = Object.keys(LS).filter(k => k.startsWith("prep_recepcion_"));
  if(keys.length === 0) {
    lista.innerHTML = "<div style='opacity:0.5; padding:20px'>No hay pedidos en preparaci√≥n.</div>";
    return;
  }

  keys.reverse().forEach(k => {
    const ref = k.replace("prep_recepcion_", "");
    const meta = JSON.parse(LS.getItem(KM(ref)) || "{}");
    const lines = JSON.parse(LS.getItem(k) || "[]");
    const totalLines = lines.length;

    const completeLines = lines.filter(l => (toNum(l.qty_recibida)) >= (toNum(l.qty_pedida))).length;
    const anyReceived = lines.some(l => (toNum(l.qty_recibida)) > 0);

    let badgeClass = "b-p"; let badgeText = "Pendiente";
    if (totalLines > 0 && completeLines === totalLines) { badgeClass = "b-c"; badgeText = "Completo"; }
    else if (totalLines > 0 && anyReceived) { badgeClass = "b-pa"; badgeText = "Parcial"; }

    const fab = !!meta.en_fabricacion;

    // NO ASIGNADO pendiente (pill persistente)
    // Primero en meta; si no existe (p.ej. el pedido ya no est√° en Preparaci√≥n), se toma del registro global.
    const ubLocal = (meta && meta.unassignedBorrow) ? meta.unassignedBorrow : null;
    const ubGlobal = getGlobalBorrow(ref);
    const ub = (ubLocal && Array.isArray(ubLocal.items) && ubLocal.items.length) ? ubLocal : ubGlobal;
    const ut = unassignedTotals(ub);
    const hasNoAsig = (ut.lines > 0);


    const item = document.createElement("div");
    item.className = "item";
    // dataset para auto-abrir / marcar desde Fabricaci√≥n/Almac√©n
    try{
      item.dataset.ref = ref;
      item.dataset.refNorm = normRef(ref);
    }catch(e){}
    item.innerHTML = `
      <div style="display:flex;justify-content:space-between;margin-bottom:6px; gap:10px; align-items:flex-start;">
        <span style="font-weight:bold; color:#fff">${ref}</span>
        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
          ${fab ? `<span class="badge b-fab"><span class="dot"></span> En fabricaci√≥n</span>` : ``}
          ${hasNoAsig ? `<span class="badge b-na">No asignado: <b>${ut.lines}</b></span>` : ``}
          <span class="badge ${badgeClass}">${badgeText}</span>
        </div>
      </div>
      <div style="font-size:12px; color:#9fb0c8; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
        ${meta.concepto || "Sin concepto"} (${meta.unidades || 1} uds)${(meta.empresa || meta.company) ? (" ¬∑ " + (meta.empresa || meta.company)) : ""}
      </div>`;
    item.onclick = () => abrirPedido(ref);
    lista.appendChild(item);
  });
}

/* ========= ABRIR PEDIDO ========= */
function abrirPedido(ref) {
  refActual = ref;
  document.getElementById("vistaLista").classList.add("hidden");
  document.getElementById("vistaDetalle").classList.remove("hidden");

  metaActual = JSON.parse(LS.getItem(KM(ref)) || "{}");
if (metaActual.en_fabricacion === undefined) metaActual.en_fabricacion = false;

  // Hidrataci√≥n de "No asignado" desde registro global (por si el pedido viene de otro m√≥dulo)
  const gb = getGlobalBorrow(ref);
  if(gb && (!metaActual.unassignedBorrow || !Array.isArray((metaActual.unassignedBorrow||{}).items) || metaActual.unassignedBorrow.items.length===0)){
    metaActual.unassignedBorrow = gb;
    // no forzamos guardado aqu√≠; se guardar√° al primer cambio
  }

// Si el pedido tiene deuda de "no asignado" guardada globalmente, la re-hidratamos aqu√≠
const gBorrow = getGlobalBorrow(ref);
if(gBorrow && typeof gBorrow === "object" && Array.isArray(gBorrow.items) && gBorrow.items.length){
  metaActual.unassignedBorrow = gBorrow;
}

  estadoMateriales = JSON.parse(LS.getItem(KP(ref)) || "[]");

  document.getElementById("ref").textContent = ref;
  document.getElementById("concepto").textContent = metaActual.concepto || "";
  // Empresa (por pedido)
  if(!metaActual.empresa && metaActual.company) metaActual.empresa = metaActual.company;
  if(!metaActual.company && metaActual.empresa) metaActual.company = metaActual.empresa;

  // Fallback: si el pedido ya existe en ldh_db, re-hidratar empresa (sin ligar a concepto)
  if(!(metaActual.empresa || "").trim()){
    try{
      const rawDb = LS.getItem("ldh_db");
      if(rawDb){
        const db = JSON.parse(rawDb) || {};
        const d = (db.deliveries||[]).find(x=>x && x.ref === ref);
        const emp = String((d && (d.company || d.empresa)) || "").trim();
        if(emp){
          metaActual.empresa = emp;
          metaActual.company = emp;
          LS.setItem(KM(refActual), JSON.stringify(metaActual));
        }
      }
    }catch(e){}
  }

  document.getElementById("empresaPrep").textContent = (metaActual.empresa || metaActual.company) ? ("¬∑ " + (metaActual.empresa || metaActual.company)) : "";
  document.getElementById("inputUnidades").value = (metaActual.unidades || 1);
  document.getElementById("pillFab").classList.toggle("hidden", !metaActual.en_fabricacion);

  const radios = document.getElementsByName("th");
  radios.forEach(r => r.checked = (r.value === metaActual.tipo_hierro));

  renderTabla();
}

/* ========= GUARDADOS META ========= */
function guardarUnidadesManual() {
  const val = parseFloat(document.getElementById("inputUnidades").value) || 1;
  metaActual.unidades = val;
  LS.setItem(KM(refActual), JSON.stringify(metaActual));
}
function guardarTipoHierro(){
  const radios=document.getElementsByName("th");
  let val=""; radios.forEach(r=>{if(r.checked)val=r.value});
  metaActual.tipo_hierro=val;
  LS.setItem(KM(refActual), JSON.stringify(metaActual));
}

/* ========= AUTO-CIERRE POR RECEPCI√ìN (AHORA: ENV√çA A FABRICACI√ìN ANTES) ========= */
function autoCerrarSiCompletoPorRecepcion(){
  const totalLines = estadoMateriales.length;
  if(totalLines === 0) return;

  const completeLines = estadoMateriales.filter(l =>
    toNum(l.qty_recibida) >= toNum(l.qty_pedida)
  ).length;

  if(completeLines === totalLines){
    // 1) Asegurar que queda enviado a fabricaci√≥n antes de eliminar de Preparaci√≥n
    mandarAFabricacionAutoSiHaceFalta();

    // 2) Si hay material NO asignado pendiente, NO retiramos el pedido de Preparaci√≥n.
    //    As√≠ la alerta no desaparece y queda "bloqueado" hasta devolverlo.
    const ub = (metaActual && metaActual.unassignedBorrow) ? metaActual.unassignedBorrow : (getGlobalBorrow(refActual) || { items: [] });
    const t = unassignedTotals(ub);
    if(t.lines > 0){
      metaActual.recepcion_completa = true;
      metaActual.unassignedBorrow = ensureUnassigned(metaActual);
      // nos aseguramos de persistirlo tambi√©n en global
      saveMetaActual();
      alert("‚ö†Ô∏è Pedido completo (material recibido), pero hay MATERIAL NO ASIGNADO pendiente de devolver.\n\nEl pedido se mantiene en Preparaci√≥n hasta que lo devuelvas desde la pill roja.");
      updateNoAsigPill();
      cargarLista();
      return;
    }

    // 3) Retirar de Preparaci√≥n (solo si NO hay no-asignado pendiente)
    LS.removeItem(KP(refActual));
    LS.removeItem(KM(refActual));
    alert("‚úÖ Pedido completo (material recibido): enviado a Fabricaci√≥n y retirado de Preparaci√≥n.");
    volverLista();
  }
}

/* ========= VINCULACI√ìN ========= */
function getLinkedMatIdForLine(line){
  if(line.linked_matId && getMatById(line.linked_matId)) return line.linked_matId;
  const k = linkKeyFor(line);
  const rec = linkMap[k];
  if(rec && rec.matId && getMatById(rec.matId)) return rec.matId;
  return null;
}
function setLinkForLine(index, matId){
  const line = estadoMateriales[index];
  const mat = getMatById(matId);
  if(!mat) return;

  line.linked_matId = matId;

  const k = linkKeyFor(line);
  linkMap[k] = { matId: matId, name: mat.name, cat: mat.cat, grp: mat.grp, unit: mat.unit };
  saveLinkMap();

  guardarEstadoLocal();
  renderTabla();
  cargarLista();
}
function clearLinkForLine(index){
  const line = estadoMateriales[index];
  line.linked_matId = null;
  guardarEstadoLocal();
  renderTabla();
}

/* ========= MODAL VINCULAR ========= */
function abrirModalVincular(index){
  linkModalCtx = { lineIndex: index, chosenMatId: null };

  const line = estadoMateriales[index];
  document.getElementById("linkLineName").textContent = `${line.mat} (${line.unit || "ud"})`;

  const input = document.getElementById("linkSearch");
  input.value = "";
  input.oninput = () => renderLinkResults();

  renderLinkResults();
  document.getElementById("modalVincular").classList.add("active");
}
function cerrarModalVincular(){
  document.getElementById("modalVincular").classList.remove("active");
  linkModalCtx = null;
}
function desvincularActual(){
  if(!linkModalCtx) return;
  clearLinkForLine(linkModalCtx.lineIndex);
  cerrarModalVincular();
}
function confirmarVinculo(){
  if(!linkModalCtx || !linkModalCtx.chosenMatId){
    alert("Selecciona un material del listado.");
    return;
  }
  setLinkForLine(linkModalCtx.lineIndex, linkModalCtx.chosenMatId);
  cerrarModalVincular();
}
function renderLinkResults(){
  const host = document.getElementById("linkResults");
  host.innerHTML = "";

  const q = normName(document.getElementById("linkSearch").value || "");

  let arr = stockMaterials.slice();
  if(q){
    arr = arr.filter(m => {
      const t = normName(`${m.name} ${m.cat} ${m.grp}`);
      return t.includes(q);
    });
  }

  arr.sort((a,b) => {
    const ac = normName(a.cat).localeCompare(normName(b.cat));
    if(ac!==0) return ac;
    const ag = normName(a.grp).localeCompare(normName(b.grp));
    if(ag!==0) return ag;
    return normName(a.name).localeCompare(normName(b.name));
  });

  if(arr.length===0){
    host.innerHTML = `<div style="padding:12px; opacity:.7;">Sin resultados.</div>`;
    return;
  }

  arr.forEach(m => {
    const qty = getStockQty(m.id);
    const el = document.createElement("div");
    el.className = "link-item" + (linkModalCtx && linkModalCtx.chosenMatId===m.id ? " active" : "");
    el.innerHTML = `
      <div class="t">${m.name}</div>
      <div class="s">
        <span>${m.cat} ‚Ä∫ ${m.grp}</span>
        <span><b>${qty}</b> ${m.unit || ""}</span>
      </div>
    `;
    el.onclick = () => {
      linkModalCtx.chosenMatId = m.id;
      renderLinkResults();
    };
    host.appendChild(el);
  });
}

/* ========= RENDER TABLA ========= */
function renderTabla() {
  const tbodyBarras = document.getElementById("tbodyBarras");
  const tbodyUnidades = document.getElementById("tbodyUnidades");
  tbodyBarras.innerHTML = "";
  tbodyUnidades.innerHTML = "";

  let hasBarras = false;
  let hasUnidades = false;

  document.getElementById("pillFab").classList.toggle("hidden", !metaActual.en_fabricacion);

  estadoMateriales.forEach((linea, index) => {
    const pedida = toNum(linea.qty_pedida);
    const recibida = toNum(linea.qty_recibida);
    const yaAplicada = toNum(linea.aplicado_qty);

    const isComplete = linea.ok || (pedida > 0 && recibida >= pedida);
    const rowClass = isComplete ? "ok" : "";

    const linkedId = getLinkedMatIdForLine(linea);
    const linkedMat = linkedId ? getMatById(linkedId) : null;
    const stockQty = linkedId ? getStockQty(linkedId) : null;

    let stockPill = "";
    if(linkedMat){
      const s = toNum(stockQty);
      let cls = "ok";
      if(s <= 0) cls = "danger";
      else if(pedida > 0 && s < pedida) cls = "warn";
      stockPill = `<span class="link-pill ${cls}">Stock: <b>${s}</b> ${linkedMat.unit || ""}</span>`;
    } else {
      stockPill = `<span class="link-pill">Sin v√≠nculo</span>`;
    }

    const diff = recibida - yaAplicada;
    const falta = Math.max(0, pedida - recibida);

    let btnHtml = "";
    if (diff > 0) {
      btnHtml += `<button class="btn-mini" onclick="guardarLinea(${index})">A√±adir a stock (+${diff})</button>`;
    } else if (yaAplicada > 0) {
      btnHtml += `<button class="btn-mini disabled">‚úÖ OK</button>`;
    } else {
      btnHtml += `<span style="opacity:0.2">-</span>`;
    }

    if (falta > 0) {
      btnHtml += `<button class="btn-mini" onclick="consumirDeStock(${index})">Consumir stock (-${falta})</button>`;
      btnHtml += `<button class="btn-mini unassigned" onclick="consumirNoAsignado(${index})">Consumir NO asignado</button>`;
    }

    // Si existe deuda no asignada para esta l√≠nea, ofrecer devoluci√≥n desde Preparaci√≥n
    const uaRec = _uaFindForLine(linea);
    if(uaRec && uaRec.pending>0){
      btnHtml += `<button class="btn-mini btn-danger" onclick="devolverNoAsignadoLinea(${index})">Devolver no asignado (+${uaRec.pending})</button>`;
    }

    const btnVincular = `<button class="btn-mini" onclick="abrirModalVincular(${index})">Vincular</button>`;

    const tr = document.createElement("tr");
    tr.className = rowClass;

    tr.innerHTML = `
      <td><input type="checkbox" ${linea.ok ? "checked" : ""} onchange="toggleOk(${index}, this.checked)"></td>
      <td>
        <div style="font-weight:700; color:#fff;">${linea.mat}</div>
        <div class="stock-mini">
          ${stockPill}
          ${linkedMat ? `<span class="small">Vinculado a: <b>${linkedMat.name}</b></span>` : `<span class="small">Pulsa ‚ÄúVincular‚Äù para emparejar con Stock</span>`}
          ${yaAplicada > 0 ? `<span class="small">Sumado a stock: <b>${yaAplicada}</b></span>` : ``}
        </div>
      </td>
      <td>${pedida} <span style="font-size:10px;opacity:0.5">${linea.unit || 'ud'}</span></td>
      <td><input type="number" value="${recibida}" oninput="updateQty(${index}, this)"></td>
      <td>${btnHtml}${btnVincular}</td>
      <td><input type="text" value="${linea.note || ''}" onchange="updateNote(${index}, this.value)" style="width:100%"></td>
    `;

    if ((linea.unit || "").toLowerCase() === 'barra') { hasBarras = true; tbodyBarras.appendChild(tr); }
    else { hasUnidades = true; tbodyUnidades.appendChild(tr); }
  });

  document.getElementById("bloqueBarras").classList.toggle("hidden", !hasBarras);
  document.getElementById("bloqueUnidades").classList.toggle("hidden", !hasUnidades);
  document.getElementById("panelHierro").classList.toggle("hidden", !hasBarras);

  autoCerrarSiCompletoPorRecepcion();
  updateNoAsigPill();
}


/* ========= L√ìGICA DE STOCK: localizar material ========= */
function _addToRealStock_byLinkedOrName(linea, ironType) {
  const linkedId = getLinkedMatIdForLine(linea);
  if(linkedId){
    const mat = getMatById(linkedId);
    if(mat) return { success:true, mat, matId: linkedId };
  }

  const baseName = String(linea.mat||"");
  let candidates = [];
  if (ironType && (String(linea.unit||"").toLowerCase().includes('barra'))) {
    candidates.push(baseName + " " + ironType.charAt(0).toUpperCase() + ironType.slice(1));
    candidates.push(baseName + " " + ironType.toLowerCase());
  }
  candidates.push(baseName);

  let mat = null;
  for (let candidate of candidates) {
    const cn = normName(candidate);
    mat = stockMaterials.find(m => normName(m.name) === cn);
    if (mat) break;
  }
  const searchedName = candidates.length > 0 ? candidates[0] : baseName;
  if (!mat) return { success:false, searchedName };

  return { success:true, mat, matId: mat.id };
}

/* ========= A√ëADIR A STOCK (movimiento "in") ========= */
function guardarLinea(index) {
  const linea = estadoMateriales[index];
  const recibido = toNum(linea.qty_recibida);
  const yaAplicado = toNum(linea.aplicado_qty);
  const diff = recibido - yaAplicado;

  if (diff <= 0) return;

  let tipoHierro = null;
  if ((String(linea.unit||"").toLowerCase() === 'barra')) {
    tipoHierro = metaActual.tipo_hierro;
    if (!tipoHierro) {
      alert("‚ö†Ô∏è Selecciona el tipo de perfiler√≠a (Galvanizado/Negro) arriba.");
      const p = document.getElementById("panelHierro");
      p.style.boxShadow = "0 0 0 2px #ef4444";
      setTimeout(()=>p.style.boxShadow="none", 2000);
      return;
    }
  }

  const check = _addToRealStock_byLinkedOrName(linea, tipoHierro);

  if (!check.success) {
    abrirModalCreacion({
      name: check.searchedName,
      unit: linea.unit,
      diff: diff,
      index: index
    });
    return;
  }

  stockMovements.push({ id: uuid(), matId: check.matId, type: 'in', qty: diff, date: new Date().toISOString() });
  saveStockLocal();

  linea.aplicado_qty = yaAplicado + diff;
  guardarEstadoLocal();

  const newTotal = getStockQty(check.matId);
  alert(`‚úÖ Stock Actualizado.\nMaterial: ${check.mat.name}\nTotal: ${newTotal}`);
  renderTabla();
}

/* ========= CONSUMIR DE STOCK (movimiento "out") ========= */
function consumirDeStock(index){
  const linea = estadoMateriales[index];

  const pedida = toNum(linea.qty_pedida);
  const recibida = toNum(linea.qty_recibida);

  const falta = Math.max(0, pedida - recibida);
  if(falta <= 0){
    alert("Esta l√≠nea ya est√° completa.");
    return;
  }

  let tipoHierro = null;
  if ((String(linea.unit||"").toLowerCase() === 'barra')) {
    tipoHierro = metaActual.tipo_hierro;
    if (!tipoHierro) {
      alert("‚ö†Ô∏è Selecciona el tipo de perfiler√≠a (Galvanizado/Negro) arriba.");
      const p = document.getElementById("panelHierro");
      p.style.boxShadow = "0 0 0 2px #ef4444";
      setTimeout(()=>p.style.boxShadow="none", 2000);
      return;
    }
  }

  const check = _addToRealStock_byLinkedOrName(linea, tipoHierro);
  if(!check.success){
    alert("Este material no est√° vinculado / no existe en Stock.\nPulsa ‚ÄúVincular‚Äù y selecciona el material correcto antes de consumir.");
    return;
  }

  const matId = check.matId;
  const mat = check.mat;

  const disponible = toNum(getStockQty(matId));
  const quedaria = disponible - falta;

  if(quedaria < 0){
    const deficit = Math.abs(quedaria);
    const ok = confirm(
      `Stock insuficiente para consumir.\n\n` +
      `Material: ${mat.name}\n` +
      `Disponible: ${disponible}\n` +
      `Necesario: ${falta}\n\n` +
      `Esto dejar√° el stock en NEGATIVO: -${deficit}\n\n` +
      `¬øConfirmas consumir igualmente?`
    );
    if(!ok) return;
  }

  stockMovements.push({
    id: uuid(),
    matId: matId,
    type: 'out',
    qty: falta,
    date: new Date().toISOString(),
    ref: refActual,
    concept: metaActual.concepto || ""
  });
  saveStockLocal();

  linea.qty_recibida = recibida + falta;
  linea.ok = (toNum(linea.qty_recibida) >= pedida);

  guardarEstadoLocal();

  alert(`‚úÖ Consumido de stock.\nMaterial: ${mat.name}\nCantidad: ${falta}\nStock actual: ${getStockQty(matId)}`);
  renderTabla();
  cargarLista();
}


/* ========= CONSUMIR NO ASIGNADO (movimiento "out" + alerta) ========= */
function consumirNoAsignado(index){
  const linea = estadoMateriales[index];

  const pedida = toNum(linea.qty_pedida);
  const recibida = toNum(linea.qty_recibida);

  const falta = Math.max(0, pedida - recibida);
  if(falta <= 0){
    alert("Esta l√≠nea ya est√° completa.");
    return;
  }

  let tipoHierro = null;
  if ((String(linea.unit||"").toLowerCase() === 'barra')) {
    tipoHierro = metaActual.tipo_hierro;
    if (!tipoHierro) {
      alert("‚ö†Ô∏è Selecciona el tipo de perfiler√≠a (Galvanizado/Negro) arriba.");
      const p = document.getElementById("panelHierro");
      p.style.boxShadow = "0 0 0 2px #ef4444";
      setTimeout(()=>p.style.boxShadow="none", 2000);
      return;
    }
  }

  const check = _addToRealStock_byLinkedOrName(linea, tipoHierro);
  if(!check.success){
    alert("Este material no est√° vinculado / no existe en Stock.\nPulsa ‚ÄúVincular‚Äù y selecciona el material correcto antes de consumir NO asignado.");
    return;
  }

  const matId = check.matId;
  const mat = check.mat;

  // Cantidad a consumir (m√°x falta)
  const ask = prompt(`Cantidad a CONSUMIR como NO asignado (m√°x. ${falta})`, String(falta));
  if(ask === null) return;
  let q = parseFloat(String(ask).replace(",", "."));
  if(isNaN(q) || q <= 0) return;
  if(q > falta) q = falta;

  const disponible = toNum(getStockQty(matId));
  const quedaria = disponible - q;

  if(quedaria < 0){
    const deficit = Math.abs(quedaria);
    const ok = confirm(
      `Stock insuficiente para consumir NO asignado.\n\n` +
      `Material: ${mat.name}\n` +
      `Disponible: ${disponible}\n` +
      `Necesario: ${q}\n\n` +
      `Esto dejar√° el stock en NEGATIVO: -${deficit}\n\n` +
      `¬øConfirmas consumir igualmente?`
    );
    if(!ok) return;
  }

  stockMovements.push({
    id: uuid(),
    matId: matId,
    type: 'out',
    qty: q,
    date: new Date().toISOString(),
    ref: refActual,
    concept: metaActual.concepto || "",
    reason: "unassigned_borrow"
  });
  saveStockLocal();

  // Cumple la recepci√≥n de la l√≠nea (igual que consumir normal)
  linea.qty_recibida = recibida + q;
  linea.ok = (toNum(linea.qty_recibida) >= pedida);

  // Registrar deuda por pedido (multi-material)
  const ub = ensureUnassigned(metaActual);
  const found = (ub.items || []).find(it => it && it.matId === matId);
  if(found){
    found.qtyPending = toNum(found.qtyPending) + q;
    found.lastActionAt = Date.now();
  }else{
    (ub.items || (ub.items=[])).push({
      matId: matId,
      name: mat.name,
      unit: mat.unit || (linea.unit || ""),
      qtyPending: q,
      createdAt: Date.now(),
      lastActionAt: Date.now()
    });
  }
  metaActual.unassignedBorrow = ub;
  saveMetaActual();

  guardarEstadoLocal();

  alert(`‚ö†Ô∏è Consumido material NO asignado.\nMaterial: ${mat.name}\nCantidad: ${q}\n\nQueda pendiente devolverlo.`);
  updateNoAsigPill();
  renderTabla();
  cargarLista();
}


/* ========= MODAL CREACI√ìN ========= */
function abrirModalCreacion(data) {
  pendingCreation = data;
  document.getElementById("modMatName").textContent = data.name;

  const cats = [...new Set(stockMaterials.map(m => m.cat).filter(Boolean))].sort();
  const selCat = document.getElementById("modCatSelect");
  selCat.innerHTML = `<option value="" disabled selected>-- Elige Categor√≠a --</option>` +
                     cats.map(c => `<option value="${c}">${c}</option>`).join("");

  document.getElementById("modGrpSelect").innerHTML = `<option value="" disabled selected>-- Elige Categor√≠a primero --</option>`;

  document.getElementById("modQtyInput").value = data.diff;
  document.getElementById("modUnitInput").value = data.unit || "ud";
  document.getElementById("modMinInput").value = "";

  document.getElementById("modCatInput").value = "";
  document.getElementById("modGrpInput").value = "";
  document.getElementById("modCatInput").classList.add("hidden");
  document.getElementById("modGrpInput").classList.add("hidden");
  document.getElementById("modCatSelect").classList.remove("hidden");
  document.getElementById("modGrpSelect").classList.remove("hidden");

  document.getElementById("modalCrear").classList.add("active");
}
function cerrarModalCreacion() {
  document.getElementById("modalCrear").classList.remove("active");
  pendingCreation = null;
}
function toggleInput(type) {
  const sel = document.getElementById(type === 'cat' ? "modCatSelect" : "modGrpSelect");
  const inp = document.getElementById(type === 'cat' ? "modCatInput" : "modGrpInput");

  if (inp.classList.contains("hidden")) {
    sel.classList.add("hidden");
    inp.classList.remove("hidden");
    inp.focus();
  } else {
    inp.classList.add("hidden");
    sel.classList.remove("hidden");
  }
}
function cargarGruposModal() {
  const cat = document.getElementById("modCatSelect").value;
  const grps = [...new Set(stockMaterials.filter(m => m.cat === cat).map(m => m.grp).filter(Boolean))].sort();

  const selGrp = document.getElementById("modGrpSelect");
  selGrp.innerHTML = `<option value="" disabled selected>-- Elige Grupo --</option>` +
                     grps.map(g => `<option value="${g}">${g}</option>`).join("");
}
function guardarNuevoMaterial() {
  if (!pendingCreation) return;

  const catInput = document.getElementById("modCatInput");
  const catVal = !catInput.classList.contains("hidden") ? catInput.value.trim() : document.getElementById("modCatSelect").value;
  const grpInput = document.getElementById("modGrpInput");
  const grpVal = !grpInput.classList.contains("hidden") ? grpInput.value.trim() : document.getElementById("modGrpSelect").value;

  const unitVal = document.getElementById("modUnitInput").value.trim() || "ud";
  const minVal = parseInt(document.getElementById("modMinInput").value) || 0;
  const qtyVal = parseFloat(document.getElementById("modQtyInput").value) || 0;

  if (!catVal || !grpVal) { alert("Por favor, indica Categor√≠a y Grupo."); return; }
  if (qtyVal <= 0) { alert("La cantidad a sumar debe ser mayor que 0."); return; }

  const newId = uuid();
  stockMaterials.push({
    id: newId,
    cat: catVal,
    grp: grpVal,
    name: pendingCreation.name,
    unit: unitVal,
    min: minVal
  });

  stockMovements.push({
    id: uuid(),
    matId: newId,
    type: 'in',
    qty: qtyVal,
    date: new Date().toISOString()
  });

  saveStockLocal();

  const linea = estadoMateriales[pendingCreation.index];
  linea.linked_matId = newId;

  const k = linkKeyFor(linea);
  linkMap[k] = { matId: newId, name: pendingCreation.name, cat: catVal, grp: grpVal, unit: unitVal };
  saveLinkMap();

  linea.aplicado_qty = toNum(linea.aplicado_qty) + qtyVal;
  guardarEstadoLocal();

  alert(`‚úÖ Ficha creada y stock a√±adido.\n\nUbicaci√≥n: ${catVal} > ${grpVal}\nCantidad sumada: ${qtyVal} ${unitVal}`);
  cerrarModalCreacion();
  renderTabla();
}

/* ========= OTROS HELPERS ========= */
function toggleOk(index, isChecked) {
  const linea = estadoMateriales[index];
  linea.ok = isChecked;
  if (isChecked) {
    const pedida = toNum(linea.qty_pedida);
    if (pedida > 0) linea.qty_recibida = pedida;
  }
  guardarEstadoLocal();
  renderTabla();
  cargarLista();
}
function updateQty(index, inputEl) {
  let val = parseFloat(inputEl.value);
  if (isNaN(val)) val = 0;
  const linea = estadoMateriales[index];
  const pedida = toNum(linea.qty_pedida);

  if (pedida > 0 && val > pedida) {
    val = pedida;
    inputEl.value = val;
    inputEl.classList.remove("flash-limit"); void inputEl.offsetWidth; inputEl.classList.add("flash-limit");
  }
  if (val < 0) { val = 0; inputEl.value = 0; }

  linea.qty_recibida = val;
  linea.ok = (pedida > 0 && val >= pedida);

  guardarEstadoLocal();
  inputEl.onblur = () => { renderTabla(); cargarLista(); };
}
function updateNote(index, txt) { estadoMateriales[index].note = txt; guardarEstadoLocal(); }
function marcarTodoOk() {
  estadoMateriales.forEach(l => {
    l.ok = true;
    const pedida = toNum(l.qty_pedida);
    if(pedida > 0) l.qty_recibida = pedida;
  });
  guardarEstadoLocal();
  renderTabla();
  cargarLista();
}
function guardarEstadoLocal() { LS.setItem(KP(refActual), JSON.stringify(estadoMateriales)); }

/* ========= MANDAR A FABRICACI√ìN (MANUAL) ========= */
function confirmarTodoRecepcion() {
  const hayBarras = estadoMateriales.some(l => (String(l.unit||"").toLowerCase() === 'barra'));
  if (hayBarras && !metaActual.tipo_hierro) { alert("‚ö†Ô∏è Selecciona el tipo de perfiler√≠a."); return; }

  const val = parseFloat(document.getElementById("inputUnidades").value) || metaActual.unidades || 0;
  if (val <= 0) { alert("‚õî Indica las UNIDADES."); document.getElementById("inputUnidades").focus(); return; }

  if (!confirm(`Mandar a FABRICACI√ìN:\nUnidades: ${val}\n\n(El pedido seguir√° en Preparaci√≥n hasta que todo el material est√© recibido.)`)) return;
  mandarAFabricacion(val, true);
}

/* ========= MANDAR A FABRICACI√ìN (CORE) ========= */
function mandarAFabricacion(unidadesFinal, withAlert) {
  if (!refActual) return;

  const rawDb = LS.getItem("ldh_db");
  let db = { deliveries: [] };
  if (rawDb) { try { db = JSON.parse(rawDb); if (!Array.isArray(db.deliveries)) db.deliveries = []; } catch (e) {} }

  const idx = db.deliveries.findIndex(d => d.ref === refActual);

  const notaHierro = metaActual.tipo_hierro ? `[PERFILER√çA: ${metaActual.tipo_hierro.toUpperCase()}] ` : "";
  const notasFinales = notaHierro + "Enviado desde Preparaci√≥n.";
  const empresaFinal = String(metaActual.empresa || metaActual.company || "").trim();

  if (idx >= 0) {
    db.deliveries[idx].total = unidadesFinal;
    // Mantener empresa por pedido en ldh_db
    if(empresaFinal){
      db.deliveries[idx].company = empresaFinal;
      db.deliveries[idx].empresa  = empresaFinal;
    } else {
      if(!db.deliveries[idx].company && db.deliveries[idx].empresa) db.deliveries[idx].company = db.deliveries[idx].empresa;
      if(!db.deliveries[idx].empresa && db.deliveries[idx].company) db.deliveries[idx].empresa = db.deliveries[idx].company;
    }
    db.deliveries[idx].unassignedBorrow = (metaActual.unassignedBorrow || getGlobalBorrow(refActual) || { items: [], updatedAt: Date.now() });
    if (!db.deliveries[idx].notes) db.deliveries[idx].notes = "";
    if (!db.deliveries[idx].notes.includes("Enviado desde Preparaci√≥n")) {
      db.deliveries[idx].notes = (db.deliveries[idx].notes ? (db.deliveries[idx].notes + "\n") : "") + notasFinales;
    }
  } else {
    db.deliveries.push({
      unassignedBorrow: ((metaActual.unassignedBorrow || getGlobalBorrow(refActual) || { items: [], updatedAt: Date.now() })),
      id: "PED-" + Date.now(),
      client: "Taller / Interno",
      ref: refActual,
      company: empresaFinal || "",
      empresa: empresaFinal || "",
      concept: metaActual.concepto || "Sin concepto",
      datePed: new Date().toISOString().split('T')[0],
      datePrev: new Date().toISOString().split('T')[0],
      status: "pendiente",
      priority: "normal",
      total: unidadesFinal,
      delivered: 0,
      history: [],
      notes: notasFinales
    });
  }

  LS.setItem("ldh_db", JSON.stringify(db));

  metaActual.en_fabricacion = true;
  metaActual.fabricacion_ts = metaActual.fabricacion_ts || Date.now();
  LS.setItem(KM(refActual), JSON.stringify(metaActual));

  document.getElementById("pillFab").classList.remove("hidden");
  if(withAlert){
    alert(`‚úÖ Enviado a Fabricaci√≥n.\nUds: ${unidadesFinal}\n\n(Queda en Preparaci√≥n hasta completar recepci√≥n.)`);
  }
  cargarLista();
}

/* ========= AUTO: ENVIAR A FABRICACI√ìN SI HACE FALTA ========= */
function mandarAFabricacionAutoSiHaceFalta(){
  // Evitar re-enviar (y duplicar notas/acciones) cuando ya existe en Fabricaci√≥n.
  // Esto es importante porque al devolver NO-ASIGNADO puede dispararse el auto-cierre de recepci√≥n.
  if(!refActual) return;

  if(metaActual && metaActual.en_fabricacion && ldhHasDelivery(refActual)){
    // Aseguramos mirror de no-asignado por si cambi√≥
    mirrorUnassignedToLdhDb();
    return;
  }
  if(ldhHasDelivery(refActual)){
    metaActual.en_fabricacion = true;
    metaActual.fabricacion_ts = metaActual.fabricacion_ts || Date.now();
    LS.setItem(KM(refActual), JSON.stringify(metaActual));
    mirrorUnassignedToLdhDb();
    return;
  }

  const unidadesFinal = (parseFloat(document.getElementById("inputUnidades")?.value) || metaActual.unidades || 1);
  mandarAFabricacion(unidadesFinal, false);
}


/* ========= ELIMINAR ========= */
function eliminarPedido() {
  if (confirm("‚õî ¬øEliminar?")) {
    LS.removeItem(KP(refActual));
    LS.removeItem(KM(refActual));
    clearGlobalBorrow(refActual);
    volverLista();
  }
}

/* ========= INIT ========= */
async function init(){
  loadLinkMap();
  loadStockLocal();

  if(USE_FIRESTORE_STOCK){
    try{
      fbEnsure();
      await fsLoginHidden();
      await fsLoadOnceToLocal();
      fsReady = true;
      fsStartRealtimeListener();
    }catch(e){
      console.warn("Firestore no disponible, seguimos con local stock:", e);
      fsReady = false;
    }
  }

  cargarLista();
  // si venimos desde el index con ?openRef=...
  autoAbrirDesdeQuery();
}
init();
</script>


<script>
/* ========= AUTO CLOUD SYNC (FULL LOCALSTORAGE) - COMPAT =========
   - Login an√≥nimo si existe auth
   - Last-Write-Wins por 'rev' en backups/backup_main
*/
(function(){
  const DOC_ID = "backup_main";
  const REV_KEY = "__cloud_backup_rev";
  const CID_KEY = "__cloud_client_id";
  const DEBOUNCE_MS = 2500;

  let applyingRemote = false;
  let timer = null;
  let currentRev = Number(localStorage.getItem(REV_KEY) || "0") || 0;

  function getClientId(){
    let cid = localStorage.getItem(CID_KEY);
    if(!cid){
      cid = "cid_" + Math.random().toString(16).slice(2) + "_" + Date.now();
      localStorage.setItem(CID_KEY, cid);
    }
    return cid;
  }

  function fbReady(){
    return (window.firebase && firebase.apps && firebase.apps.length);
  }

  function ensureFb(){
    if(!window.firebase) return false;
    // si ya hay init, ok
    if(firebase.apps && firebase.apps.length) return true;
    // si el html tiene firebaseConfig global, inicializamos
    try{
      if(window.firebaseConfig) firebase.initializeApp(window.firebaseConfig);
      return true;
    }catch(e){
      console.warn("AutoSync: no se pudo inicializar firebase", e);
      return false;
    }
  }

  async function ensureAuth(){
    try{
      if(!firebase.auth) return;
      const auth = firebase.auth();
      if(!auth.currentUser){
        await auth.signInAnonymously();
      }
    }catch(e){
      // si reglas permiten sin auth, no bloqueamos
    }
  }

  async function backupAll(reason){
    try{
      const db = firebase.firestore();
      const cid = getClientId();
      const all = {};
      for(let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        all[k] = localStorage.getItem(k);
      }
      const json = JSON.stringify(all);
      const CHUNK = 800000;
      const total = Math.ceil(json.length / CHUNK);
      const rev = Date.now();

      const metaRef = db.collection("backups").doc(DOC_ID);
      await metaRef.set({
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
        rev: rev,
        updatedBy: cid,
        reason: String(reason||""),
        totalChunks: total,
        totalBytes: json.length,
        totalKeys: Object.keys(all).length
      }, { merge: true });

      const chunksCol = metaRef.collection("chunks");
      const batch = db.batch();
      for(let i=0;i<total;i++){
        const part = json.slice(i*CHUNK, (i+1)*CHUNK);
        const cRef = chunksCol.doc(String(i));
        batch.set(cRef, { i, part });
      }
      await batch.commit();

      currentRev = rev;
      localStorage.setItem(REV_KEY, String(rev));
    }catch(e){
      console.warn("‚ùå AutoSync backup error:", e);
    }
  }

  async function restoreAll(){
    const db = firebase.firestore();
    const metaRef = db.collection("backups").doc(DOC_ID);
    const metaSnap = await metaRef.get();
    if(!metaSnap.exists) return;
    const meta = metaSnap.data() || {};
    const total = meta.totalChunks || 0;
    if(!total) return;

    let json = "";
    for(let i=0;i<total;i++){
      const cSnap = await metaRef.collection("chunks").doc(String(i)).get();
      if(!cSnap.exists) throw new Error("Falta chunk " + i);
      json += (cSnap.data().part || "");
    }
    const all = JSON.parse(json);
    localStorage.clear();
    for(const k in all) localStorage.setItem(k, all[k]);
    currentRev = Number(meta.rev || Date.now());
    localStorage.setItem(REV_KEY, String(currentRev));
  }

  function schedule(reason){
    if(applyingRemote) return;
    clearTimeout(timer);
    timer = setTimeout(()=>backupAll(reason), DEBOUNCE_MS);
  }

  function hookStorage(){
    const _setItem = localStorage.setItem.bind(localStorage);
    const _removeItem = localStorage.removeItem.bind(localStorage);
    const _clear = localStorage.clear.bind(localStorage);

    localStorage.setItem = function(k,v){
      const r=_setItem(k,v);
      if(k!==REV_KEY && k!==CID_KEY) schedule("setItem");
      return r;
    };
    localStorage.removeItem = function(k){
      const r=_removeItem(k);
      if(k!==REV_KEY && k!==CID_KEY) schedule("removeItem");
      return r;
    };
    localStorage.clear = function(){
      const r=_clear();
      schedule("clear");
      return r;
    };
    window.addEventListener("storage", (ev)=>{
      if(!ev) return;
      if(ev.key===REV_KEY || ev.key===CID_KEY) return;
      schedule("storage_event");
    });
  }

  function isLocalEmpty(){
    let n=0;
    for(let i=0;i<localStorage.length;i++){
      const k=localStorage.key(i);
      if(k===REV_KEY || k===CID_KEY) continue;
      n++;
      if(n>0) break;
    }
    return n===0;
  }

  async function boot(){
    if(!ensureFb()) return;
    await ensureAuth();
    hookStorage();

    const db = firebase.firestore();
    const cid = getClientId();
    const metaRef = db.collection("backups").doc(DOC_ID);

    // restore inicial si local vac√≠o
    if(isLocalEmpty()){
      try{
        const metaSnap = await metaRef.get();
        if(metaSnap.exists){
          const meta = metaSnap.data() || {};
          const rev = Number(meta.rev||0)||0;
          if(rev > currentRev){
            applyingRemote = true;
            await restoreAll();
            // recargar para rehidratar UI
            setTimeout(()=>location.reload(), 250);
          }
        }
      }catch(e){}
      finally{ applyingRemote = false; }
    }

    // listener remoto continuo
    metaRef.onSnapshot(async (snap)=>{
      if(!snap.exists) return;
      const meta = snap.data() || {};
      const rev = Number(meta.rev||0)||0;
      const updatedBy = String(meta.updatedBy||"");
      if(rev <= currentRev) return;
      if(updatedBy && updatedBy===cid) return;

      applyingRemote = true;
      try{
        await restoreAll();
        setTimeout(()=>location.reload(), 250);
      }catch(e){
        console.warn("‚ùå AutoSync restore error:", e);
      }finally{
        applyingRemote = false;
      }
    });

    // primer backup para crear doc si no existe
    setTimeout(()=>schedule("startup"), 3500);
  }

  // arrancar cuando el resto del script haya inicializado firebaseConfig, etc.
  const iv = setInterval(()=>{
    if(window.firebase && (window.firebaseConfig || (firebase.apps && firebase.apps.length))){
      clearInterval(iv);
      boot();
    }
  }, 500);
})();
</script>

</body>
</html>
